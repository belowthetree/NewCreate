# 3.11
---
## 编译优化
虽然编译器会优化程序员的代码，像gcc还提供了优化等级。但是采用更好的方式写出的代码，
会比更高编译器最高等级的优化得到的效果要更好。

需要注意的是，编译器的优化是安全的优化。即所有的优化都要保证程序的行为不变。
当出现一些难以判断的操作，比如指针，编译器就难以优化代码。
```
void cal1(int *xp, int *yp)
{
	*xp += *yp;
	*xp += *yp;
}
void cal2(int *xp, int *yp)
{
	*xp += 2 * *yp;
}
```
以上两个函数，在指针指向的地址不同的时候会有同样的结果，即地址xp里的值变成原来的两倍。
但是如果指针指向的地址一样，那么第一个函数就会将xp里的值变为四倍，而第二个函数将xp里的
值变成三倍。

对于一般函数编译器不会去优化，不过内联函数编译器会进行优化。
	
# 3.14
## 循环优化
---
循环展开相对于非循环展开花费指令周期较短：
```
void cal1(float a[], float p[], int n)
{
	int i;
	p[0] = a[0];
	for(i = 1;i < n;i++)
	{
		p[i] = p[i - 1] + a[i];
	}
}

void cal2(float a[], float p[], int n)
{
	int i;
	p[0] = a[0];
	for(i = 1;i < n - 1;i += 2)
	{
		p[i] = p[i - 1] + a[i];
		p[i + 1] = p[i] + a[i + 1];
	}
	if(i < n)
		p[i] = p[i - 1] + a[i];
}
```
![](第五章-优化程序性能_files/1.png)
---
书中接着给出了不同数据类型的运算效率，同样是进行上述代码的计算。

![](第五章-优化程序性能_files/1.jpg)

可以看出，运用了优化选项-o1后的代码效率更高，应尽量使用-o1或者以上的优化。
另一方面的优化方法是尽量避免在循环中进行不改变值的操作，最常见的如`for(int i = 0;i < strlen(s);i++)`
此句中的`strlen(s)`函数会导致巨大的性能浪费。应该将`strlen(s)`移除循环，用常数代替。
![](第五章-优化程序性能_files/2.jpg)
---

另一种巨大的开销是反复的内存读取。在循环中如果进行类似`a[i] = p[i] + 1;`的操作，计算机每次操作都要在内存中读取数组的值。
内存的读取是比较慢的。而如果声明一个临时变量，这个临时变量会被储存在寄存器中，速度相对会快很多。
如：
```
float b;
for(int i = 0;i < len;i++)
{
	b = p[i] + 1;
}
相比
for(int i = 0;i < len;i++)
{
	a[i] = p[i] + 1;
}
更高效
```
![](第五章-优化程序性能_files/3.jpg)